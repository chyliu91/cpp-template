# 初见函数模板
## 定义一个函数模板
下面的函数模板定义了一个函数族，根据传递的参数，返回者中的较大值：
```
template <typename T>
T max(T a, T b)
{
	return b < a ? a : b;
}
```

- 模板参数指定形式：`template <comma-separated-list-of-parameters>`
- <typename T> 这里的 `T` 也可以用其他的标识符代替，但是使用 `T` 更加方便
- 模板参数的类型必须支持 `<`
- 可以使用 `class` 关键字代替 `typename`，但是建议优先使用 `typename`

## 使用函数模板
```
#include <iostream>
#include <string>

int main()
{
	int i = 42;
	std::cout << "max(7,i):  " << ::max(7, i) << "\n";

	double f1 = 3.14;
	double f2 = -9.96;
	std::cout << "max(f1,f2):  " << ::max(f1, f2) << "\n";

	std::string s1 = "mathematics";
	std::string s2 = "math";
	std::cout << "max(s1,s2):  " << ::max(s1, s2) << "\n";
	
	return 0;
}
```
- 使用实际类型代替模板参数的过程称之为 "实例化"
- 上面的调用，实际上实例化了下面三个函数：
```
int max(int a, int b)
{
	return b < a ? a : b;
}

double max(double a, double b)
{
	return b < a ? a : b;
}

std::string max(std::string a, std::string b)
{
	return b < a ? a : b;
}
```

可以使用 `void` 类型作为模板参数：
```
template <typename T>
T foo(T*)
{
	std::cout << "foo called" << "\n";
}

void* vp = nullptr;
foo(vp);
```
## 两阶段翻译
模板编译的两个阶段:
- 定义没有实例化期间：进行忽略模板参数的相关检查：
    - 语法错误，例如是否丢失分号
    - 使用了不依赖模板参数的未知名称
    - 不依赖模板参数的静态 assertion
- 实例化期间：模板代码将被检查，特别是依赖于模板参数的部分将被检查

```
template <typename T>
void foo(T t)
{
	undeclared();  //@ 第一阶段检查，如果 undeclared() 未定义将会报错
	undeclared(t); //@ 第二阶段检查，如果 undeclared(T) 未定义将会报错

	static_assert(sizeof(int) > 10, "int too small");  //@ 总是报错，如果 sizeof(int) <= 10
	static_assert(sizeof(T) > 10, "T too small"); //@ 如果 sizeof(T) <= 0 才会报错
}
```

两阶段的翻译带来一个很大的问题：当函数模板被实例化时，编译器需要看到函数模板的定义。这与普通函数的编译不同，普通函数编译时只需要看到声明就可以了。一种简单的解决这个问题的办法就是将模板的实现写在头文件中。


# 模板参数推导










